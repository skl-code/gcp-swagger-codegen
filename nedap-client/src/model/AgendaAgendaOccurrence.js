/*
 * Nedap Ons API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.0
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 3.0.77
 *
 * Do not edit the class manually.
 *
 */
import ApiClient from '../ApiClient';
import AgendaAgendaClientInvitation from './AgendaAgendaClientInvitation';
import AgendaAgendaInvitation from './AgendaAgendaInvitation';
import AgendaLabel from './AgendaLabel';
import RecurrenceType from './RecurrenceType';

/**
 * The AgendaAgendaOccurrence model module.
 * @module model/AgendaAgendaOccurrence
 * @version 0.0.0
 */
export default class AgendaAgendaOccurrence {
  /**
   * Constructs a new <code>AgendaAgendaOccurrence</code>.
   * Agenda series domain model used by Cupido system.
   * @alias module:model/AgendaAgendaOccurrence
   * @class
   */
  constructor() {
  }

  /**
   * Constructs a <code>AgendaAgendaOccurrence</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/AgendaAgendaOccurrence} obj Optional instance to populate.
   * @return {module:model/AgendaAgendaOccurrence} The populated <code>AgendaAgendaOccurrence</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new AgendaAgendaOccurrence();
      if (data.hasOwnProperty('id'))
        obj.id = ApiClient.convertToType(data['id'], 'String');
      if (data.hasOwnProperty('occurrenceDate'))
        obj.occurrenceDate = ApiClient.convertToType(data['occurrenceDate'], 'Date');
      if (data.hasOwnProperty('uuid'))
        obj.uuid = ApiClient.convertToType(data['uuid'], 'String');
      if (data.hasOwnProperty('groupUuid'))
        obj.groupUuid = ApiClient.convertToType(data['groupUuid'], 'String');
      if (data.hasOwnProperty('name'))
        obj.name = ApiClient.convertToType(data['name'], 'String');
      if (data.hasOwnProperty('comment'))
        obj.comment = ApiClient.convertToType(data['comment'], 'String');
      if (data.hasOwnProperty('timelineId'))
        obj.timelineId = ApiClient.convertToType(data['timelineId'], 'Number');
      if (data.hasOwnProperty('validFrom'))
        obj.validFrom = ApiClient.convertToType(data['validFrom'], 'Date');
      if (data.hasOwnProperty('validTo'))
        obj.validTo = ApiClient.convertToType(data['validTo'], 'Date');
      if (data.hasOwnProperty('startTime'))
        obj.startTime = ApiClient.convertToType(data['startTime'], 'String');
      if (data.hasOwnProperty('endTime'))
        obj.endTime = ApiClient.convertToType(data['endTime'], 'String');
      if (data.hasOwnProperty('startsAt'))
        obj.startsAt = ApiClient.convertToType(data['startsAt'], 'Date');
      if (data.hasOwnProperty('endsAt'))
        obj.endsAt = ApiClient.convertToType(data['endsAt'], 'Date');
      if (data.hasOwnProperty('duration'))
        obj.duration = ApiClient.convertToType(data['duration'], 'Number');
      if (data.hasOwnProperty('recurrenceType'))
        obj.recurrenceType = RecurrenceType.constructFromObject(data['recurrenceType']);
      if (data.hasOwnProperty('cycleInterval'))
        obj.cycleInterval = ApiClient.convertToType(data['cycleInterval'], 'Number');
      if (data.hasOwnProperty('customLocation'))
        obj.customLocation = ApiClient.convertToType(data['customLocation'], 'String');
      if (data.hasOwnProperty('registered'))
        obj.registered = ApiClient.convertToType(data['registered'], 'Boolean');
      if (data.hasOwnProperty('registrationComplete'))
        obj.registrationComplete = ApiClient.convertToType(data['registrationComplete'], 'Boolean');
      if (data.hasOwnProperty('creatorObjectId'))
        obj.creatorObjectId = ApiClient.convertToType(data['creatorObjectId'], 'Number');
      if (data.hasOwnProperty('monday'))
        obj.monday = ApiClient.convertToType(data['monday'], 'Boolean');
      if (data.hasOwnProperty('tuesday'))
        obj.tuesday = ApiClient.convertToType(data['tuesday'], 'Boolean');
      if (data.hasOwnProperty('wednesday'))
        obj.wednesday = ApiClient.convertToType(data['wednesday'], 'Boolean');
      if (data.hasOwnProperty('thursday'))
        obj.thursday = ApiClient.convertToType(data['thursday'], 'Boolean');
      if (data.hasOwnProperty('friday'))
        obj.friday = ApiClient.convertToType(data['friday'], 'Boolean');
      if (data.hasOwnProperty('saturday'))
        obj.saturday = ApiClient.convertToType(data['saturday'], 'Boolean');
      if (data.hasOwnProperty('sunday'))
        obj.sunday = ApiClient.convertToType(data['sunday'], 'Boolean');
      if (data.hasOwnProperty('hourTypeId'))
        obj.hourTypeId = ApiClient.convertToType(data['hourTypeId'], 'Number');
      if (data.hasOwnProperty('clientPresent'))
        obj.clientPresent = ApiClient.convertToType(data['clientPresent'], 'Boolean');
      if (data.hasOwnProperty('private'))
        obj._private = ApiClient.convertToType(data['private'], 'Boolean');
      if (data.hasOwnProperty('agendaInvitations'))
        obj.agendaInvitations = ApiClient.convertToType(data['agendaInvitations'], [AgendaAgendaInvitation]);
      if (data.hasOwnProperty('agendaClientInvitations'))
        obj.agendaClientInvitations = ApiClient.convertToType(data['agendaClientInvitations'], [AgendaAgendaClientInvitation]);
      if (data.hasOwnProperty('labels'))
        obj.labels = ApiClient.convertToType(data['labels'], [AgendaLabel]);
    }
    return obj;
  }
}

/**
 * Identifier of this occurrence
 * @member {String} id
 */
AgendaAgendaOccurrence.prototype.id = undefined;

/**
 * Date on which this occurrence occurs based on the recurrence rule
 * @member {Date} occurrenceDate
 */
AgendaAgendaOccurrence.prototype.occurrenceDate = undefined;

/**
 * External reference for `AgendaSeries` to which this occurrence belongs External parties can use this for their own bookkeeping. Is generated if not provided. If provided, it must be unique, will result in 422 otherwise. Every change at one point in a appointment series, results in a new `AgendaSeries` for which the `uuid` must be unique.
 * @member {String} uuid
 */
AgendaAgendaOccurrence.prototype.uuid = undefined;

/**
 * @member {String} groupUuid
 */
AgendaAgendaOccurrence.prototype.groupUuid = undefined;

/**
 * Short summary of the event, like a subject or title
 * @member {String} name
 */
AgendaAgendaOccurrence.prototype.name = undefined;

/**
 * Longer description of the event, like notes
 * @member {String} comment
 */
AgendaAgendaOccurrence.prototype.comment = undefined;

/**
 * Identifier of the `AgendaSeries`  Exceptions to the series have the same `timelineId` as the series.
 * @member {Number} timelineId
 */
AgendaAgendaOccurrence.prototype.timelineId = undefined;

/**
 * Start date of the appointment series
 * @member {Date} validFrom
 */
AgendaAgendaOccurrence.prototype.validFrom = undefined;

/**
 * Recurrence end date  If recurring, the event is recurring up to this date (exclusive)
 * @member {Date} validTo
 */
AgendaAgendaOccurrence.prototype.validTo = undefined;

/**
 * Start time of this occurrence
 * @member {String} startTime
 */
AgendaAgendaOccurrence.prototype.startTime = undefined;

/**
 * End time of this occurrence
 * @member {String} endTime
 */
AgendaAgendaOccurrence.prototype.endTime = undefined;

/**
 * Start datetime of this occurrence. It is currently readonly, but it's recommended to include the field; current: When creating or updating an AgendaOccurrence the start_time and end_time fields are used by Ons Agenda. The starts_at and ends_at fields will be deprecated. future: When creating or updating an AgendaOccurrence the starts_at and ends_at fields are used by Ons Agenda. The start_time and end_time fields will be ignored and eventually be removed.
 * @member {Date} startsAt
 */
AgendaAgendaOccurrence.prototype.startsAt = undefined;

/**
 * End datetime of this occurrence. It is currently readonly, but it's recommended to include the field; current: When creating or updating an AgendaOccurrence the start_time and end_time fields are used by Ons Agenda. The starts_at and ends_at fields will be deprecated. future: When creating or updating an AgendaOccurrence the starts_at and ends_at fields are used by Ons Agenda. The start_time and end_time fields will be ignored and eventually be removed.
 * @member {Date} endsAt
 */
AgendaAgendaOccurrence.prototype.endsAt = undefined;

/**
 * Duration in seconds. Read-only.
 * @member {Number} duration
 * @default 0
 */
AgendaAgendaOccurrence.prototype.duration = 0;

/**
 * @member {module:model/RecurrenceType} recurrenceType
 */
AgendaAgendaOccurrence.prototype.recurrenceType = undefined;

/**
 * Interval length of the series  For a recurrenceType of `monthly`, an interval of `2` means this event happens every 2 months.
 * @member {Number} cycleInterval
 * @default 0
 */
AgendaAgendaOccurrence.prototype.cycleInterval = 0;

/**
 * @member {String} customLocation
 */
AgendaAgendaOccurrence.prototype.customLocation = undefined;

/**
 * Indication if any employee has registered the appointment
 * @member {Boolean} registered
 */
AgendaAgendaOccurrence.prototype.registered = undefined;

/**
 * Indication that all employees have registered the appointment
 * @member {Boolean} registrationComplete
 */
AgendaAgendaOccurrence.prototype.registrationComplete = undefined;

/**
 * @member {Number} creatorObjectId
 */
AgendaAgendaOccurrence.prototype.creatorObjectId = undefined;

/**
 * Weekly event occurs on monday
 * @member {Boolean} monday
 */
AgendaAgendaOccurrence.prototype.monday = undefined;

/**
 * Weekly event occurs on tuesday
 * @member {Boolean} tuesday
 */
AgendaAgendaOccurrence.prototype.tuesday = undefined;

/**
 * Weekly event occurs on wednesday
 * @member {Boolean} wednesday
 */
AgendaAgendaOccurrence.prototype.wednesday = undefined;

/**
 * Weekly event occurs on thursday
 * @member {Boolean} thursday
 */
AgendaAgendaOccurrence.prototype.thursday = undefined;

/**
 * Weekly event occurs on friday
 * @member {Boolean} friday
 */
AgendaAgendaOccurrence.prototype.friday = undefined;

/**
 * Weekly event occurs on saturday
 * @member {Boolean} saturday
 */
AgendaAgendaOccurrence.prototype.saturday = undefined;

/**
 * Weekly event occurs on sunday
 * @member {Boolean} sunday
 */
AgendaAgendaOccurrence.prototype.sunday = undefined;

/**
 * Identifier of HourType  When using the per-client product selection (part of _uitgebreide workflow_), use the `hourTypeId` field in the client invitations instead
 * @member {Number} hourTypeId
 */
AgendaAgendaOccurrence.prototype.hourTypeId = undefined;

/**
 * Whether the client is expected in this event
 * @member {Boolean} clientPresent
 */
AgendaAgendaOccurrence.prototype.clientPresent = undefined;

/**
 * Whether this event is private
 * @member {Boolean} _private
 */
AgendaAgendaOccurrence.prototype._private = undefined;

/**
 * Clients, locations, teams or employees invited to this occurrence  Does not support clients when using per-client product selection (part of _uitgebreide workflow_). When per-client product selection is enabled, use `agendaClientInvitations` instead to invite clients.
 * @member {Array.<module:model/AgendaAgendaInvitation>} agendaInvitations
 */
AgendaAgendaOccurrence.prototype.agendaInvitations = undefined;

/**
 * Clients invited to this appointment  When _not_ using per-client product selection (part of _uitgebreide workflow_) use `agendaInvitations` instead to invite clients.
 * @member {Array.<module:model/AgendaAgendaClientInvitation>} agendaClientInvitations
 */
AgendaAgendaOccurrence.prototype.agendaClientInvitations = undefined;

/**
 * @member {Array.<module:model/AgendaLabel>} labels
 */
AgendaAgendaOccurrence.prototype.labels = undefined;

