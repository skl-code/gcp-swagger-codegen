/*
 * Nedap Ons API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.0
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 3.0.77
 *
 * Do not edit the class manually.
 *
 */
import ApiClient from '../ApiClient';
import RecurrenceType from './RecurrenceType';
import TasqueCareTaskGroup from './TasqueCareTaskGroup';
import TasqueExecutor from './TasqueExecutor';
import TasqueSubject from './TasqueSubject';

/**
 * The TasqueCareTaskSeries model module.
 * @module model/TasqueCareTaskSeries
 * @version 0.0.0
 */
export default class TasqueCareTaskSeries {
  /**
   * Constructs a new <code>TasqueCareTaskSeries</code>.
   * Care Task series domain model used by Cupido system. Only used for creating new care tasks
   * @alias module:model/TasqueCareTaskSeries
   * @class
   */
  constructor() {
  }

  /**
   * Constructs a <code>TasqueCareTaskSeries</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/TasqueCareTaskSeries} obj Optional instance to populate.
   * @return {module:model/TasqueCareTaskSeries} The populated <code>TasqueCareTaskSeries</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new TasqueCareTaskSeries();
      if (data.hasOwnProperty('id'))
        obj.id = ApiClient.convertToType(data['id'], 'Number');
      if (data.hasOwnProperty('uuid'))
        obj.uuid = ApiClient.convertToType(data['uuid'], 'String');
      if (data.hasOwnProperty('type'))
        obj.type = ApiClient.convertToType(data['type'], 'String');
      if (data.hasOwnProperty('subType'))
        obj.subType = ApiClient.convertToType(data['subType'], 'String');
      if (data.hasOwnProperty('subTypeId'))
        obj.subTypeId = ApiClient.convertToType(data['subTypeId'], 'String');
      if (data.hasOwnProperty('manual'))
        obj.manual = ApiClient.convertToType(data['manual'], 'Boolean');
      if (data.hasOwnProperty('limitView'))
        obj.limitView = ApiClient.convertToType(data['limitView'], 'Boolean');
      if (data.hasOwnProperty('groupName'))
        obj.groupName = ApiClient.convertToType(data['groupName'], 'String');
      if (data.hasOwnProperty('name'))
        obj.name = ApiClient.convertToType(data['name'], 'String');
      if (data.hasOwnProperty('comment'))
        obj.comment = ApiClient.convertToType(data['comment'], 'String');
      if (data.hasOwnProperty('url'))
        obj.url = ApiClient.convertToType(data['url'], 'String');
      if (data.hasOwnProperty('validFrom'))
        obj.validFrom = ApiClient.convertToType(data['validFrom'], 'Date');
      if (data.hasOwnProperty('validTo'))
        obj.validTo = ApiClient.convertToType(data['validTo'], 'Date');
      if (data.hasOwnProperty('recurrenceType'))
        obj.recurrenceType = RecurrenceType.constructFromObject(data['recurrenceType']);
      if (data.hasOwnProperty('startAfter'))
        obj.startAfter = ApiClient.convertToType(data['startAfter'], 'String');
      if (data.hasOwnProperty('finishBefore'))
        obj.finishBefore = ApiClient.convertToType(data['finishBefore'], 'String');
      if (data.hasOwnProperty('expectedDuration'))
        obj.expectedDuration = ApiClient.convertToType(data['expectedDuration'], 'Number');
      if (data.hasOwnProperty('monday'))
        obj.monday = ApiClient.convertToType(data['monday'], 'Boolean');
      if (data.hasOwnProperty('tuesday'))
        obj.tuesday = ApiClient.convertToType(data['tuesday'], 'Boolean');
      if (data.hasOwnProperty('wednesday'))
        obj.wednesday = ApiClient.convertToType(data['wednesday'], 'Boolean');
      if (data.hasOwnProperty('thursday'))
        obj.thursday = ApiClient.convertToType(data['thursday'], 'Boolean');
      if (data.hasOwnProperty('friday'))
        obj.friday = ApiClient.convertToType(data['friday'], 'Boolean');
      if (data.hasOwnProperty('saturday'))
        obj.saturday = ApiClient.convertToType(data['saturday'], 'Boolean');
      if (data.hasOwnProperty('sunday'))
        obj.sunday = ApiClient.convertToType(data['sunday'], 'Boolean');
      if (data.hasOwnProperty('cycleInterval'))
        obj.cycleInterval = ApiClient.convertToType(data['cycleInterval'], 'Number');
      if (data.hasOwnProperty('cycleBase'))
        obj.cycleBase = ApiClient.convertToType(data['cycleBase'], 'Date');
      if (data.hasOwnProperty('subject'))
        obj.subject = TasqueSubject.constructFromObject(data['subject']);
      if (data.hasOwnProperty('executors'))
        obj.executors = ApiClient.convertToType(data['executors'], [TasqueExecutor]);
      if (data.hasOwnProperty('creatorId'))
        obj.creatorId = ApiClient.convertToType(data['creatorId'], 'Number');
      if (data.hasOwnProperty('careTaskGroup'))
        obj.careTaskGroup = TasqueCareTaskGroup.constructFromObject(data['careTaskGroup']);
      if (data.hasOwnProperty('autoExpireAfter'))
        obj.autoExpireAfter = ApiClient.convertToType(data['autoExpireAfter'], 'Number');
      if (data.hasOwnProperty('morning'))
        obj.morning = ApiClient.convertToType(data['morning'], 'Boolean');
      if (data.hasOwnProperty('afternoon'))
        obj.afternoon = ApiClient.convertToType(data['afternoon'], 'Boolean');
      if (data.hasOwnProperty('evening'))
        obj.evening = ApiClient.convertToType(data['evening'], 'Boolean');
      if (data.hasOwnProperty('night'))
        obj.night = ApiClient.convertToType(data['night'], 'Boolean');
      if (data.hasOwnProperty('rights'))
        obj.rights = ApiClient.convertToType(data['rights'], ['String']);
      if (data.hasOwnProperty('hideExpiredSubject'))
        obj.hideExpiredSubject = ApiClient.convertToType(data['hideExpiredSubject'], 'Boolean');
    }
    return obj;
  }
}

/**
 * @member {Number} id
 */
TasqueCareTaskSeries.prototype.id = undefined;

/**
 * UUID from source or autogenerated to enforce uniqueness
 * @member {String} uuid
 */
TasqueCareTaskSeries.prototype.uuid = undefined;

/**
 * The type of the task <pre> Possible values: BeforeTask DuringTask </pre>
 * @member {String} type
 */
TasqueCareTaskSeries.prototype.type = undefined;

/**
 * Type of task to group multiple tasks. For example care_plan_base_renew, survey_base_review, profile etc.
 * @member {String} subType
 */
TasqueCareTaskSeries.prototype.subType = undefined;

/**
 * ID to uniquely identify the task in the subType. For example in care_plan_base_renew the client id and for survey_base_review the survey id, etc.
 * @member {String} subTypeId
 */
TasqueCareTaskSeries.prototype.subTypeId = undefined;

/**
 * Manual tasks are allowed to mark as finished manually
 * @member {Boolean} manual
 */
TasqueCareTaskSeries.prototype.manual = undefined;

/**
 * True if the task should only be visible to the executors
 * @member {Boolean} limitView
 */
TasqueCareTaskSeries.prototype.limitView = undefined;

/**
 * @member {String} groupName
 */
TasqueCareTaskSeries.prototype.groupName = undefined;

/**
 * The title of the task
 * @member {String} name
 */
TasqueCareTaskSeries.prototype.name = undefined;

/**
 * A comment added to a task
 * @member {String} comment
 */
TasqueCareTaskSeries.prototype.comment = undefined;

/**
 * URL to where the task can be executed
 * @member {String} url
 */
TasqueCareTaskSeries.prototype.url = undefined;

/**
 * Begin date of the task
 * @member {Date} validFrom
 */
TasqueCareTaskSeries.prototype.validFrom = undefined;

/**
 * End date of the task
 * @member {Date} validTo
 */
TasqueCareTaskSeries.prototype.validTo = undefined;

/**
 * @member {module:model/RecurrenceType} recurrenceType
 */
TasqueCareTaskSeries.prototype.recurrenceType = undefined;

/**
 * The time on the validFrom date the task should be started to be executed
 * @member {String} startAfter
 */
TasqueCareTaskSeries.prototype.startAfter = undefined;

/**
 * The time on the validTo date the task should be finished before
 * @member {String} finishBefore
 */
TasqueCareTaskSeries.prototype.finishBefore = undefined;

/**
 * Expected duration of task in seconds
 * @member {Number} expectedDuration
 * @default 0
 */
TasqueCareTaskSeries.prototype.expectedDuration = 0;

/**
 * True if task happens on Monday
 * @member {Boolean} monday
 */
TasqueCareTaskSeries.prototype.monday = undefined;

/**
 * True if task happens on Tuesday
 * @member {Boolean} tuesday
 */
TasqueCareTaskSeries.prototype.tuesday = undefined;

/**
 * True if task happens on Wednesday
 * @member {Boolean} wednesday
 */
TasqueCareTaskSeries.prototype.wednesday = undefined;

/**
 * True if task happens on Thursday
 * @member {Boolean} thursday
 */
TasqueCareTaskSeries.prototype.thursday = undefined;

/**
 * True if task happens on Friday
 * @member {Boolean} friday
 */
TasqueCareTaskSeries.prototype.friday = undefined;

/**
 * True if task happens on Saturday
 * @member {Boolean} saturday
 */
TasqueCareTaskSeries.prototype.saturday = undefined;

/**
 * True if task happens on Sunday
 * @member {Boolean} sunday
 */
TasqueCareTaskSeries.prototype.sunday = undefined;

/**
 * The interval of the cycle based on the recurrence type
 * @member {Number} cycleInterval
 * @default 0
 */
TasqueCareTaskSeries.prototype.cycleInterval = 0;

/**
 * Date on which the task cycle starts
 * @member {Date} cycleBase
 */
TasqueCareTaskSeries.prototype.cycleBase = undefined;

/**
 * @member {module:model/TasqueSubject} subject
 */
TasqueCareTaskSeries.prototype.subject = undefined;

/**
 * A list of employees, locations, teams, expertise profiles or expertise groups
 * @member {Array.<module:model/TasqueExecutor>} executors
 */
TasqueCareTaskSeries.prototype.executors = undefined;

/**
 * ID of the person who created the task
 * @member {Number} creatorId
 */
TasqueCareTaskSeries.prototype.creatorId = undefined;

/**
 * @member {module:model/TasqueCareTaskGroup} careTaskGroup
 */
TasqueCareTaskSeries.prototype.careTaskGroup = undefined;

/**
 * Amount of days after which the task should automatically expire
 * @member {Number} autoExpireAfter
 */
TasqueCareTaskSeries.prototype.autoExpireAfter = undefined;

/**
 * True if task should happen in the morning
 * @member {Boolean} morning
 */
TasqueCareTaskSeries.prototype.morning = undefined;

/**
 * True is task should happen in the afternoon
 * @member {Boolean} afternoon
 */
TasqueCareTaskSeries.prototype.afternoon = undefined;

/**
 * True is task should happen in the evening
 * @member {Boolean} evening
 */
TasqueCareTaskSeries.prototype.evening = undefined;

/**
 * True is task should happen in the night
 * @member {Boolean} night
 */
TasqueCareTaskSeries.prototype.night = undefined;

/**
 * A list of rights
 * @member {Array.<String>} rights
 */
TasqueCareTaskSeries.prototype.rights = undefined;

/**
 * @member {Boolean} hideExpiredSubject
 */
TasqueCareTaskSeries.prototype.hideExpiredSubject = undefined;

