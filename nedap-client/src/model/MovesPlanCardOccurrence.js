/*
 * Nedap Ons API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.0
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 3.0.77
 *
 * Do not edit the class manually.
 *
 */
import ApiClient from '../ApiClient';
import MovesContainerAssignment from './MovesContainerAssignment';
import MovesPlanCardRecurrenceInformation from './MovesPlanCardRecurrenceInformation';
import MovesPlannedAddress from './MovesPlannedAddress';

/**
 * The MovesPlanCardOccurrence model module.
 * @module model/MovesPlanCardOccurrence
 * @version 0.0.0
 */
export default class MovesPlanCardOccurrence {
  /**
   * Constructs a new <code>MovesPlanCardOccurrence</code>.
   * A single instance of a recurring plan card as retrieved from the new Plancore.
   * @alias module:model/MovesPlanCardOccurrence
   * @class
   * @param occurrenceId {String} The ID that links to this specific plan card occurrence
   * @param planCardChecksum {String} The url-encoded checksum used to check if planning changes are made with the correct updated data
   * @param planCardTimelineId {Number} The timeline id that links this plan card occurrence to the other moments that were planned in the past and in the future
   * @param clientId {Number} The identifier of the client that is linked to this plan card
   * @param hourTypeId {Number} The identifier of the hour type attached to this planned care moment
   * @param durationInSeconds {Number} The total duration in seconds that this planned care moment is going to take.
   * @param travelTimeBeforeInSeconds {Number} The total duration in seconds that is calculated to travel from the previous plan card to this plan card
   * @param travelTimeAfterInSeconds {Number} The total duration in seconds that is calculated to travel from the current plan card to the next plan card
   * @param transportationMethodId {Number} The identifier of the transportation method that is being used to travel to this plan card
   * @param _date {Date} Date on which this PlanCardOccurrence occurs.
   * @param startDateTime {Date} Date and start time on which this PlanCardOccurrence occurs.
   * @param fixedStartTime {String} The local fixed start time on which this PlanCardOccurrence should occur. This time remains the same when going through DST changes.
   * @param incidental {Boolean} Whether this PlanCardOccurrence has been incidentally changed for only this date
   * @param canceled {Boolean} Whether this PlanCardOccurrence has been incidentally canceled for this date
   * @param address {module:model/MovesPlannedAddress} 
   * @param assignment {module:model/MovesContainerAssignment} 
   * @param recurrence {module:model/MovesPlanCardRecurrenceInformation} 
   */
  constructor(occurrenceId, planCardChecksum, planCardTimelineId, clientId, hourTypeId, durationInSeconds, travelTimeBeforeInSeconds, travelTimeAfterInSeconds, transportationMethodId, _date, startDateTime, fixedStartTime, incidental, canceled, address, assignment, recurrence) {
    this.occurrenceId = occurrenceId;
    this.planCardChecksum = planCardChecksum;
    this.planCardTimelineId = planCardTimelineId;
    this.clientId = clientId;
    this.hourTypeId = hourTypeId;
    this.durationInSeconds = durationInSeconds;
    this.travelTimeBeforeInSeconds = travelTimeBeforeInSeconds;
    this.travelTimeAfterInSeconds = travelTimeAfterInSeconds;
    this.transportationMethodId = transportationMethodId;
    this._date = _date;
    this.startDateTime = startDateTime;
    this.fixedStartTime = fixedStartTime;
    this.incidental = incidental;
    this.canceled = canceled;
    this.address = address;
    this.assignment = assignment;
    this.recurrence = recurrence;
  }

  /**
   * Constructs a <code>MovesPlanCardOccurrence</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/MovesPlanCardOccurrence} obj Optional instance to populate.
   * @return {module:model/MovesPlanCardOccurrence} The populated <code>MovesPlanCardOccurrence</code> instance.
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new MovesPlanCardOccurrence();
      if (data.hasOwnProperty('occurrenceId'))
        obj.occurrenceId = ApiClient.convertToType(data['occurrenceId'], 'String');
      if (data.hasOwnProperty('planCardChecksum'))
        obj.planCardChecksum = ApiClient.convertToType(data['planCardChecksum'], 'String');
      if (data.hasOwnProperty('planCardTimelineId'))
        obj.planCardTimelineId = ApiClient.convertToType(data['planCardTimelineId'], 'Number');
      if (data.hasOwnProperty('clientId'))
        obj.clientId = ApiClient.convertToType(data['clientId'], 'Number');
      if (data.hasOwnProperty('hourTypeId'))
        obj.hourTypeId = ApiClient.convertToType(data['hourTypeId'], 'Number');
      if (data.hasOwnProperty('durationInSeconds'))
        obj.durationInSeconds = ApiClient.convertToType(data['durationInSeconds'], 'Number');
      if (data.hasOwnProperty('travelTimeBeforeInSeconds'))
        obj.travelTimeBeforeInSeconds = ApiClient.convertToType(data['travelTimeBeforeInSeconds'], 'Number');
      if (data.hasOwnProperty('travelTimeAfterInSeconds'))
        obj.travelTimeAfterInSeconds = ApiClient.convertToType(data['travelTimeAfterInSeconds'], 'Number');
      if (data.hasOwnProperty('transportationMethodId'))
        obj.transportationMethodId = ApiClient.convertToType(data['transportationMethodId'], 'Number');
      if (data.hasOwnProperty('date'))
        obj._date = ApiClient.convertToType(data['date'], 'Date');
      if (data.hasOwnProperty('startDateTime'))
        obj.startDateTime = ApiClient.convertToType(data['startDateTime'], 'Date');
      if (data.hasOwnProperty('fixedStartTime'))
        obj.fixedStartTime = ApiClient.convertToType(data['fixedStartTime'], 'String');
      if (data.hasOwnProperty('incidental'))
        obj.incidental = ApiClient.convertToType(data['incidental'], 'Boolean');
      if (data.hasOwnProperty('canceled'))
        obj.canceled = ApiClient.convertToType(data['canceled'], 'Boolean');
      if (data.hasOwnProperty('address'))
        obj.address = MovesPlannedAddress.constructFromObject(data['address']);
      if (data.hasOwnProperty('assignment'))
        obj.assignment = MovesContainerAssignment.constructFromObject(data['assignment']);
      if (data.hasOwnProperty('recurrence'))
        obj.recurrence = MovesPlanCardRecurrenceInformation.constructFromObject(data['recurrence']);
    }
    return obj;
  }
}

/**
 * The ID that links to this specific plan card occurrence
 * @member {String} occurrenceId
 */
MovesPlanCardOccurrence.prototype.occurrenceId = undefined;

/**
 * The url-encoded checksum used to check if planning changes are made with the correct updated data
 * @member {String} planCardChecksum
 */
MovesPlanCardOccurrence.prototype.planCardChecksum = undefined;

/**
 * The timeline id that links this plan card occurrence to the other moments that were planned in the past and in the future
 * @member {Number} planCardTimelineId
 */
MovesPlanCardOccurrence.prototype.planCardTimelineId = undefined;

/**
 * The identifier of the client that is linked to this plan card
 * @member {Number} clientId
 */
MovesPlanCardOccurrence.prototype.clientId = undefined;

/**
 * The identifier of the hour type attached to this planned care moment
 * @member {Number} hourTypeId
 */
MovesPlanCardOccurrence.prototype.hourTypeId = undefined;

/**
 * The total duration in seconds that this planned care moment is going to take.
 * @member {Number} durationInSeconds
 */
MovesPlanCardOccurrence.prototype.durationInSeconds = undefined;

/**
 * The total duration in seconds that is calculated to travel from the previous plan card to this plan card
 * @member {Number} travelTimeBeforeInSeconds
 */
MovesPlanCardOccurrence.prototype.travelTimeBeforeInSeconds = undefined;

/**
 * The total duration in seconds that is calculated to travel from the current plan card to the next plan card
 * @member {Number} travelTimeAfterInSeconds
 */
MovesPlanCardOccurrence.prototype.travelTimeAfterInSeconds = undefined;

/**
 * The identifier of the transportation method that is being used to travel to this plan card
 * @member {Number} transportationMethodId
 */
MovesPlanCardOccurrence.prototype.transportationMethodId = undefined;

/**
 * Date on which this PlanCardOccurrence occurs.
 * @member {Date} _date
 */
MovesPlanCardOccurrence.prototype._date = undefined;

/**
 * Date and start time on which this PlanCardOccurrence occurs.
 * @member {Date} startDateTime
 */
MovesPlanCardOccurrence.prototype.startDateTime = undefined;

/**
 * The local fixed start time on which this PlanCardOccurrence should occur. This time remains the same when going through DST changes.
 * @member {String} fixedStartTime
 */
MovesPlanCardOccurrence.prototype.fixedStartTime = undefined;

/**
 * Whether this PlanCardOccurrence has been incidentally changed for only this date
 * @member {Boolean} incidental
 */
MovesPlanCardOccurrence.prototype.incidental = undefined;

/**
 * Whether this PlanCardOccurrence has been incidentally canceled for this date
 * @member {Boolean} canceled
 */
MovesPlanCardOccurrence.prototype.canceled = undefined;

/**
 * @member {module:model/MovesPlannedAddress} address
 */
MovesPlanCardOccurrence.prototype.address = undefined;

/**
 * @member {module:model/MovesContainerAssignment} assignment
 */
MovesPlanCardOccurrence.prototype.assignment = undefined;

/**
 * @member {module:model/MovesPlanCardRecurrenceInformation} recurrence
 */
MovesPlanCardOccurrence.prototype.recurrence = undefined;

